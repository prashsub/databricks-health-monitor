---
description: Best practices for creating Databricks Lakeview AI/BI dashboards with proper system table usage and layout formatting
globs: 
  - "**/*dashboard*.json"
  - "**/*.lvdash.json"
alwaysApply: false
---

# Databricks AI/BI Lakeview Dashboard Best Practices

> **Patterns extracted from production dashboards**: Account Usage Dashboard v2 - DAIS, Governance Hub, DBSQL Warehouse Advisor, Jobs System Tables Dashboard, LakeFlow System Tables Dashboard, Workflow Advisor Dashboard, and more.

---

## 1. Top-Level Dashboard Structure

**MANDATORY KEYS:**
```json
{
  "warehouse_id": "...",  // REQUIRED: SQL Warehouse ID for queries
  "datasets": [...],      // REQUIRED: All data sources
  "pages": [...],         // REQUIRED: Dashboard pages
  "uiSettings": {...}     // OPTIONAL: Theme and settings
}
```

**Notes:**
- `warehouse_id` IS required for SDK deployment (pass `${warehouse_id}` for variable substitution)
- `displayName` is set by deployment script, not in JSON
- `widgets` and `layout` go inside pages, not at root level

---

## 2. Dataset Structure

### 2.1 Basic Dataset
```json
{
  "name": "ds_unique_id",           // REQUIRED: Unique identifier
  "displayName": "Human Readable",  // REQUIRED: Display name
  "query": "SELECT ...",            // Option A: Single string
  "queryLines": ["SELECT ", "..."], // Option B: Array of strings
  "parameters": [...]               // OPTIONAL: Parameter definitions
}
```

### 2.2 Dataset with Parameters (CRITICAL)

**Every dataset using `:param_name` in SQL MUST define that parameter with `defaultSelection`!**

```json
{
  "name": "ds_cost_data",
  "displayName": "Cost Data",
  "query": "SELECT * FROM table WHERE date BETWEEN :time_range.min AND :time_range.max",
  "parameters": [
    {
      "displayName": "time_range",
      "keyword": "time_range",
      "dataType": "DATE",
      "complexType": "RANGE",
      "defaultSelection": {
        "range": {
          "dataType": "DATE",
          "min": { "value": "now-90d/d" },
          "max": { "value": "now/d" }
        }
      }
    }
  ]
}
```

---

## 3. Parameter Type Reference

### 3.1 DATE:RANGE (For Date Range Pickers)

**Use when query has `:time_range.min` and `:time_range.max`**

```json
{
  "displayName": "time_range",
  "keyword": "time_range",
  "dataType": "DATE",
  "complexType": "RANGE",          // ‚ö†Ô∏è CRITICAL for .min/.max
  "defaultSelection": {
    "range": {
      "dataType": "DATE",
      "min": { "value": "now-90d/d" },
      "max": { "value": "now/d" }
    }
  }
}
```

**Relative date syntax:**
- `now` - Current date/time
- `now-90d/d` - 90 days ago, rounded to day
- `now-12M/M` - 12 months ago, rounded to month
- `now-1M/M` - 1 month ago
- `2024-01-01T00:00:00.000` - Absolute date

### 3.2 DATETIME:RANGE (For Timestamp Ranges)

```json
{
  "displayName": "time_range",
  "keyword": "time_range",
  "dataType": "DATETIME",
  "complexType": "RANGE",
  "defaultSelection": {
    "range": {
      "dataType": "DATETIME",
      "min": { "value": "now-7d/d" },
      "max": { "value": "now-1d/d" }
    }
  }
}
```

### 3.3 STRING (Single Select)

**Use when query has `:param_workspace`**

```json
{
  "displayName": "param_workspace",
  "keyword": "param_workspace",
  "dataType": "STRING",
  "defaultSelection": {
    "values": {
      "dataType": "STRING",
      "values": [{ "value": "<ALL WORKSPACES>" }]
    }
  }
}
```

### 3.4 STRING:MULTI (Multi-Select)

**Use when query has `array_contains(:param_workspace, column)`**

```json
{
  "displayName": "param_workspace",
  "keyword": "param_workspace",
  "dataType": "STRING",
  "complexType": "MULTI",
  "defaultSelection": {
    "values": {
      "dataType": "STRING",
      "values": [{ "value": "all" }]
    }
  }
}
```

### 3.5 INTEGER

**Use when query has `LIMIT :param_top_n`**

```json
{
  "displayName": "param_top_n",
  "keyword": "param_top_n",
  "dataType": "INTEGER",
  "defaultSelection": {
    "values": {
      "dataType": "INTEGER",
      "values": [{ "value": "10" }]
    }
  }
}
```

### 3.6 DECIMAL

**Use for numeric inputs like amounts**

```json
{
  "displayName": "annual_commit",
  "keyword": "annual_commit",
  "dataType": "DECIMAL",
  "defaultSelection": {
    "values": {
      "dataType": "DECIMAL",
      "values": [{ "value": "1000000" }]
    }
  }
}
```

### 3.7 DATE (Single Date)

```json
{
  "displayName": "contract_start_date",
  "keyword": "contract_start_date",
  "dataType": "DATE",
  "defaultSelection": {
    "values": {
      "dataType": "DATE",
      "values": [{ "value": "2024-01-01T00:00:00.000" }]
    }
  }
}
```

---

## 4. Grid System (6-Column)

**ALWAYS use a 6-column grid layout!**

### 4.1 Position Structure
```json
{
  "position": {
    "x": 0,      // Column: 0-5
    "y": 0,      // Row: any positive integer
    "width": 3,  // Width: 1-6 (must sum to ‚â§6 per row)
    "height": 6  // Height: varies by widget type
  }
}
```

### 4.2 Common Width Patterns

| Widgets per row | Width each |
|-----------------|------------|
| 6 KPIs | 1 |
| 3 charts | 2 |
| 2 charts | 3 |
| 2 uneven | 2 + 4 |
| Full width | 6 |

### 4.3 Typical Heights by Widget Type

| Widget Type | Common Heights |
|-------------|----------------|
| counter | 2 |
| filter-single-select | 2 |
| filter-date-range-picker | 2 |
| bar | 6, 7, 8 |
| line | 5, 6 |
| table | 4, 8, 9 |
| pie | 4, 7, 8 |

### 4.4 Layout Examples
```json
// Row of 6 KPI counters
{"x": 0, "y": 0, "width": 1, "height": 2}
{"x": 1, "y": 0, "width": 1, "height": 2}
{"x": 2, "y": 0, "width": 1, "height": 2}
{"x": 3, "y": 0, "width": 1, "height": 2}
{"x": 4, "y": 0, "width": 1, "height": 2}
{"x": 5, "y": 0, "width": 1, "height": 2}

// Two side-by-side charts
{"x": 0, "y": 2, "width": 3, "height": 6}
{"x": 3, "y": 2, "width": 3, "height": 6}

// Full-width table
{"x": 0, "y": 8, "width": 6, "height": 9}
```

---

## 5. Widget Types & Encodings

### 5.1 Counter Widget (KPI)

```json
{
  "name": "kpi_total_cost",
  "queries": [{
    "name": "main_query",
    "query": {
      "datasetName": "ds_cost",
      "fields": [
        {"name": "total_cost", "expression": "`total_cost`"}
      ],
      "disaggregated": false
    }
  }],
  "spec": {
    "version": 2,
    "widgetType": "counter",
    "encodings": {
      "value": {
        "fieldName": "total_cost",
        "format": {
          "type": "number-currency",
          "currencyCode": "USD",
          "abbreviation": "none",
          "decimalPlaces": { "type": "max", "places": 0 }
        },
        "style": {
          "bold": true,
          "color": "#00A972",
          "fontSize": 32
        },
        "displayName": "Total Cost"
      },
      "target": {                    // Optional subtitle
        "fieldName": "period_label",
        "style": {
          "italic": true,
          "fontSize": 14,
          "color": { "themeColorType": "fontColor" }
        }
      }
    },
    "frame": {
      "showTitle": true,
      "title": "üí∞ Total Cost"
    }
  }
}
```

**Encoding keys:** `value`, `target` (optional)

### 5.2 Bar Chart

```json
{
  "spec": {
    "version": 3,
    "widgetType": "bar",
    "encodings": {
      "x": {
        "fieldName": "time_key",
        "scale": { "type": "temporal" },
        "displayName": "Time"
      },
      "y": {
        "fieldName": "sum(cost)",
        "scale": { "type": "quantitative" },
        "format": {
          "type": "number-currency",
          "currencyCode": "USD",
          "abbreviation": "compact"
        },
        "displayName": "Cost"
      },
      "color": {
        "fieldName": "category",
        "scale": { "type": "categorical" },
        "legend": { "hideTitle": true, "position": "right" },
        "displayName": "Category"
      }
    },
    "frame": {
      "showTitle": true,
      "title": "Cost Over Time"
    }
  }
}
```

**Encoding keys:** `x`, `y`, `color` (optional), `label` (optional)

### 5.3 Line Chart

```json
{
  "spec": {
    "version": 3,
    "widgetType": "line",
    "encodings": {
      "x": {
        "fieldName": "time_key",
        "scale": { "type": "temporal" },
        "axis": { "hideTitle": true }
      },
      "y": {
        "fieldName": "avg(metric)",
        "scale": { "type": "quantitative" },
        "format": {
          "type": "number-percent",
          "decimalPlaces": { "type": "max", "places": 1 }
        },
        "axis": { "title": "Rate" }
      },
      "label": { "show": false }
    }
  }
}
```

**Encoding keys:** `x`, `y`, `color` (optional), `label` (optional)

### 5.4 Pie Chart

**‚ö†Ô∏è Use `angle` for values, NOT `theta`!**

```json
{
  "spec": {
    "version": 3,
    "widgetType": "pie",
    "encodings": {
      "angle": {                        // NOT theta!
        "fieldName": "sum(count)",
        "scale": { "type": "quantitative" }
      },
      "color": {
        "fieldName": "category",
        "scale": {
          "type": "categorical",
          "mappings": [
            { "value": "Success", "color": { "themeColorType": "visualizationColors", "position": 1 } },
            { "value": "Failed", "color": { "themeColorType": "visualizationColors", "position": 3 } }
          ]
        },
        "legend": { "hideTitle": true }
      },
      "label": { "show": true }
    }
  }
}
```

**Encoding keys:** `angle`, `color`, `label` (optional)

### 5.5 Table Widget

**‚ö†Ô∏è CRITICAL: `disaggregated: true` required for row display!**

```json
{
  "queries": [{
    "name": "main_query",
    "query": {
      "datasetName": "ds_data",
      "fields": [
        {"name": "col1", "expression": "`col1`"},
        {"name": "col2", "expression": "`col2`"}
      ],
      "disaggregated": true           // ‚ö†Ô∏è REQUIRED for tables!
    }
  }],
  "spec": {
    "version": 1,
    "widgetType": "table",
    "encodings": {
      "columns": [
        {
          "fieldName": "col1",
          "title": "Column 1",
          "type": "string",
          "displayAs": "string",
          "visible": true,
          "order": 0,
          "allowSearch": true,
          "alignContent": "left",
          "allowHTML": true
        },
        {
          "fieldName": "col2",
          "title": "Column 2",
          "type": "number",
          "displayAs": "number",
          "visible": true,
          "order": 1
        }
      ]
    },
    "itemsPerPage": 50,
    "paginationSize": "default",
    "condensed": true,
    "withRowNumber": false
  }
}
```

**Encoding keys:** `columns`

### 5.6 Filter Single Select

```json
{
  "spec": {
    "version": 2,
    "widgetType": "filter-single-select",
    "encodings": {
      "fields": [
        {
          "fieldName": "option_value",
          "displayName": "Option",
          "queryName": "dashboards/.../option_value"
        },
        {
          "parameterName": "param_selection",
          "queryName": "parameter_dashboards/.../param_selection"
        }
      ]
    },
    "selection": {
      "defaultSelection": {
        "values": {
          "dataType": "STRING",
          "values": [{ "value": "Default" }]
        }
      }
    },
    "frame": {
      "showTitle": true,
      "title": "Select Option"
    }
  }
}
```

### 5.7 Filter Date Range Picker

```json
{
  "spec": {
    "version": 2,
    "widgetType": "filter-date-range-picker",
    "encodings": {
      "fields": [
        {
          "parameterName": "time_range",
          "queryName": "parameter_dashboards/.../time_range"
        }
      ]
    },
    "selection": {
      "defaultSelection": {
        "range": {
          "dataType": "DATE",
          "min": { "value": "now-90d/d" },
          "max": { "value": "now/d" }
        }
      }
    }
  }
}
```

---

## 5.9 ‚ö†Ô∏è CRITICAL: Global Filter Pattern

**Global filters in Databricks AI/BI dashboards use the built-in "Global Filters" pane, which is a SPECIAL PAGE TYPE - `PAGE_TYPE_GLOBAL_FILTERS`!**

This is NOT a regular page with filter widgets. It's a dedicated collapsible pane that appears on the left side of the dashboard.

### ‚ö†Ô∏è KEY LEARNING: Two Components Required

1. **Global Filters PAGE** - Uses `pageType: "PAGE_TYPE_GLOBAL_FILTERS"` (NOT `PAGE_TYPE_CANVAS`)
2. **Filter Widget** - With `queries[]` binding to ALL datasets with that parameter

### Complete Global Filters Page Structure

```json
{
  "pages": [
    {
      "name": "global_filters_page",
      "displayName": "Global Filters",
      "pageType": "PAGE_TYPE_GLOBAL_FILTERS",   // ‚ö†Ô∏è CRITICAL: NOT PAGE_TYPE_CANVAS!
      "layout": [
        {
          "widget": {
            "name": "filter_time_range",
            "queries": [
              // ONE query per dataset - binds filter to that dataset
              {
                "name": "parameter_dashboards/{dashboard_id}/datasets/{ds1_name}_time_range",
                "query": {
                  "datasetName": "ds_cost_data",
                  "parameters": [{"name": "time_range", "keyword": "time_range"}],
                  "disaggregated": false
                }
              },
              {
                "name": "parameter_dashboards/{dashboard_id}/datasets/{ds2_name}_time_range", 
                "query": {
                  "datasetName": "ds_trend_data",
                  "parameters": [{"name": "time_range", "keyword": "time_range"}],
                  "disaggregated": false
                }
              },
              {
                "name": "parameter_dashboards/{dashboard_id}/datasets/{ds3_name}_time_range",
                "query": {
                  "datasetName": "ds_summary_data", 
                  "parameters": [{"name": "time_range", "keyword": "time_range"}],
                  "disaggregated": false
                }
              }
              // ... repeat for ALL datasets using this parameter
            ],
            "spec": {
              "version": 2,
              "widgetType": "filter-date-range-picker",
              "encodings": {
                "fields": [
                  // ONE field per dataset - maps parameter to query
                  {"parameterName": "time_range", "queryName": "parameter_dashboards/{dashboard_id}/datasets/{ds1_name}_time_range"},
                  {"parameterName": "time_range", "queryName": "parameter_dashboards/{dashboard_id}/datasets/{ds2_name}_time_range"},
                  {"parameterName": "time_range", "queryName": "parameter_dashboards/{dashboard_id}/datasets/{ds3_name}_time_range"}
                  // ... repeat for ALL datasets
                ]
              },
              "selection": {
                "defaultSelection": {
                  "range": {
                    "dataType": "DATE",
                    "min": {"value": "now-90d/d"},
                    "max": {"value": "now/d"}
                  }
                }
              },
              "frame": {
                "showTitle": true,
                "title": "Time Window"
              }
            }
          },
          "position": {"x": 0, "y": 0, "width": 6, "height": 2}
        }
        // Can add more filter widgets here (workspace filter, etc.)
      ]
    },
    {
      "name": "overview_page",
      "displayName": "Overview",
      "pageType": "PAGE_TYPE_CANVAS",  // Regular content pages use PAGE_TYPE_CANVAS
      "layout": [/* ... widgets ... */]
    }
  ]
}
```

### Key Points:
1. **`pageType: "PAGE_TYPE_GLOBAL_FILTERS"`** - This creates the collapsible filter pane, NOT a regular page tab
2. **Each query in `queries[]` binds to ONE dataset** - You need one query per dataset
3. **Each `encodings.fields` entry references ONE query** - Maps the filter selection to that dataset's parameter
4. **Number of queries = Number of datasets to filter** - ALL datasets using the parameter need a binding
5. **All datasets MUST have matching `parameters[]` with same keyword** - The parameter definition MUST exist in each dataset

### ‚ùå WRONG: Using PAGE_TYPE_CANVAS for Global Filters

```json
{
  "pageType": "PAGE_TYPE_CANVAS",  // ‚ùå This creates a regular page tab!
  "displayName": "Global Filters"  // This will show as a page, not a filter pane
}
```

### ‚úÖ CORRECT: Using PAGE_TYPE_GLOBAL_FILTERS

```json
{
  "pageType": "PAGE_TYPE_GLOBAL_FILTERS",  // ‚úÖ Creates the built-in filter pane
  "displayName": "Global Filters"           // Pane label in collapsed state
}
```

### Required Dataset Parameter Structure

Each dataset that should be filtered MUST have its own `parameters[]` definition with defaults:

```json
{
  "name": "ds_cost_data",
  "query": "SELECT * FROM table WHERE date BETWEEN :time_range.min AND :time_range.max",
  "parameters": [
    {
      "displayName": "time_range",
      "keyword": "time_range",
      "dataType": "DATE",
      "complexType": "RANGE",
      "defaultSelection": {
        "range": {
          "dataType": "DATE",
          "min": {"value": "now-90d/d"},
          "max": {"value": "now/d"}
        }
      }
    }
  ]
}
```

### Python Script Pattern to Add Global Filters

When programmatically adding global filters to all datasets:

```python
def add_global_filters(dashboard: dict) -> dict:
    """Add global filters page that binds to all datasets with time_range parameter."""
    
    # Collect all datasets that have time_range parameter
    filtered_datasets = []
    for ds in dashboard.get('datasets', []):
        for param in ds.get('parameters', []):
            if param.get('keyword') == 'time_range':
                filtered_datasets.append(ds['name'])
                break
    
    if not filtered_datasets:
        return dashboard
    
    # Build queries array - one per dataset
    filter_queries = []
    filter_fields = []
    
    for ds_name in filtered_datasets:
        query_name = f"parameter_dashboards/dummy/datasets/{ds_name}_time_range"
        filter_queries.append({
            "name": query_name,
            "query": {
                "datasetName": ds_name,
                "parameters": [{"name": "time_range", "keyword": "time_range"}],
                "disaggregated": False
            }
        })
        filter_fields.append({
            "parameterName": "time_range",
            "queryName": query_name
        })
    
    # Create global filters page
    global_filters_page = {
        "name": "global_filters",
        "displayName": "Global Filters",
        "pageType": "PAGE_TYPE_GLOBAL_FILTERS",  # ‚ö†Ô∏è CRITICAL!
        "layout": [{
            "widget": {
                "name": "filter_time_range",
                "queries": filter_queries,
                "spec": {
                    "version": 2,
                    "widgetType": "filter-date-range-picker",
                    "encodings": {"fields": filter_fields},
                    "selection": {
                        "defaultSelection": {
                            "range": {
                                "dataType": "DATE",
                                "min": {"value": "now-90d/d"},
                                "max": {"value": "now/d"}
                            }
                        }
                    },
                    "frame": {"showTitle": True, "title": "Time Window"}
                }
            },
            "position": {"x": 0, "y": 0, "width": 6, "height": 2}
        }]
    }
    
    # Insert global filters page as FIRST page
    dashboard['pages'] = [global_filters_page] + dashboard['pages']
    
    return dashboard
```

### 5.8 Filter Multi-Select

```json
{
  "spec": {
    "version": 2,
    "widgetType": "filter-multi-select",
    "encodings": {
      "fields": [
        {
          "fieldName": "option_value",
          "displayName": "Options",
          "queryName": "dashboards/.../option_value"
        }
      ]
    },
    "frame": {
      "showTitle": true,
      "title": "Select Multiple"
    }
  }
}
```

---

## 6. Query Structure in Widgets

### 6.1 Basic Query

```json
{
  "queries": [{
    "name": "main_query",
    "query": {
      "datasetName": "ds_name",       // Must match dataset.name
      "fields": [
        {"name": "col", "expression": "`col`"},
        {"name": "sum(val)", "expression": "SUM(`val`)"}
      ],
      "disaggregated": false          // false=aggregate, true=rows
    }
  }]
}
```

### 6.2 Field Expressions

```json
// Simple column
{"name": "column_name", "expression": "`column_name`"}

// Aggregation
{"name": "sum(revenue)", "expression": "SUM(`revenue`)"}
{"name": "count(*)", "expression": "COUNT(*)"}
{"name": "avg(duration)", "expression": "AVG(`duration`)"}

// Conditional
{"name": "count_success", "expression": "COUNT_IF(`status` = 'SUCCESS')"}
```

### 6.3 Query with Parameter Binding

```json
{
  "query": {
    "datasetName": "ds_data",
    "fields": [...],
    "disaggregated": false,
    "parameters": [
      { "name": "time_range", "keyword": "time_range" }
    ]
  }
}
```

---

## 7. Format Types Reference

### 7.1 Currency
```json
{
  "type": "number-currency",
  "currencyCode": "USD",
  "abbreviation": "none",            // or "compact" for K/M/B
  "decimalPlaces": { "type": "max", "places": 0 }
}
```

### 7.2 Percentage
```json
{
  "type": "number-percent",
  "decimalPlaces": { "type": "max", "places": 1 }
}
```

### 7.3 Plain Number
```json
{
  "type": "number-plain",
  "abbreviation": "compact",
  "decimalPlaces": { "type": "exact", "places": 2 }
}
```

### 7.4 Date/Time
```json
{
  "type": "date-time",
  "date": "locale-short-month",
  "time": "none"
}
```

---

## 8. Scale Types Reference

| Scale Type | Use For |
|------------|---------|
| `temporal` | Time/date on x-axis |
| `quantitative` | Numeric values on y-axis |
| `categorical` | Categories, groups |

---

## 9. Style Examples

```json
// Bold green value
{"bold": true, "color": "#00A972", "fontSize": 32}

// Theme-aware italic subtitle
{"italic": true, "fontSize": 14, "color": {"themeColorType": "fontColor"}}

// Colored from palette
{"bold": true, "fontSize": 32, "color": {"themeColorType": "visualizationColors", "position": 9}}
```

---

## 10. System Tables Reference

### 10.1 Jobs Tables
```sql
-- system.lakeflow.jobs (SCD2)
SELECT workspace_id, job_id, name, run_as, tags
FROM system.lakeflow.jobs
WHERE delete_time IS NULL
QUALIFY ROW_NUMBER() OVER(PARTITION BY workspace_id, job_id ORDER BY change_time DESC) = 1

-- system.lakeflow.job_task_run_timeline
SELECT workspace_id, job_id, run_id, task_key, result_state, termination_code
FROM system.lakeflow.job_task_run_timeline
-- Note: NO job_name column! Must JOIN with jobs table
```

### 10.2 Compute Tables
```sql
-- system.compute.clusters
SELECT workspace_id, cluster_id, cluster_name, dbr_version
FROM system.compute.clusters
WHERE delete_time IS NULL
```

### 10.3 Billing Tables
```sql
-- system.billing.usage
SELECT usage_date, workspace_id, sku_name, usage_quantity, list_cost
FROM system.billing.usage
WHERE usage_date BETWEEN :time_range.min AND :time_range.max
```

---

## 11. Common Pitfalls

### ‚ùå Missing `complexType: "RANGE"` for date ranges
```json
// WRONG - will cause UNBOUND_SQL_PARAMETER error
{
  "keyword": "time_range",
  "dataType": "DATE",
  "defaultSelection": {...}
}

// CORRECT
{
  "keyword": "time_range",
  "dataType": "DATE",
  "complexType": "RANGE",
  "defaultSelection": {...}
}
```

### ‚ùå Using `theta` instead of `angle` for pie charts
```json
// WRONG
"encodings": { "theta": {...} }

// CORRECT
"encodings": { "angle": {...} }
```

### ‚ùå Missing `disaggregated: true` for tables
```json
// WRONG - table shows no rows
"query": { "datasetName": "ds", "fields": [...], "disaggregated": false }

// CORRECT
"query": { "datasetName": "ds", "fields": [...], "disaggregated": true }
```

### ‚ùå Parameter keyword doesn't match SQL
```json
// SQL uses :time_range but parameter has different keyword
"query": "WHERE date BETWEEN :time_range.min AND :time_range.max"
"parameters": [{ "keyword": "date_range", ... }]  // WRONG!

// CORRECT - keywords must match
"parameters": [{ "keyword": "time_range", ... }]
```

### ‚ùå Using 12-column grid
```json
// WRONG - widgets won't display correctly
{"x": 0, "y": 0, "width": 12, "height": 6}

// CORRECT - use 6-column grid
{"x": 0, "y": 0, "width": 6, "height": 6}
```

---

## 12. Verification Checklist

Before deploying a dashboard:

### Parameters
- [ ] Every `:param_name` in SQL has matching parameter definition
- [ ] Date range parameters have `complexType: "RANGE"`
- [ ] All parameters have `defaultSelection`
- [ ] Parameter `keyword` exactly matches SQL usage

### Widgets
- [ ] Counter widgets use `encodings.value` (not `period`)
- [ ] Pie charts use `encodings.angle` (not `theta`)
- [ ] Tables have `disaggregated: true` in query
- [ ] Bar/line charts have proper scale types

### Layout
- [ ] All positions use 6-column grid (width 1-6)
- [ ] No overlapping widgets
- [ ] Consistent heights per widget type

### Datasets
- [ ] All referenced `datasetName` exist in `datasets` array
- [ ] Field `expression` uses backticks for columns
- [ ] Aggregations use proper SQL functions

---

## 13. Reference Dashboards

These production dashboards were analyzed to extract these patterns:

1. **Account Usage Dashboard v2 - DAIS** - 28 datasets, 70 widgets
2. **Governance Hub System Dashboard** - 30 datasets, 47 widgets
3. **DBSQL Warehouse Advisor** - 19 datasets, 122 widgets
4. **Jobs System Tables Dashboard** - 22 datasets, 33 widgets
5. **LakeFlow System Tables Dashboard** - 35 datasets, 75 widgets
6. **Workflow Advisor Dashboard** - 3 datasets, 61 widgets

---

## 14. Quick Reference Card

| Pattern | Value |
|---------|-------|
| Grid columns | 6 |
| Counter height | 2 |
| Chart height | 6-8 |
| Table height | 4-9 |
| Filter height | 2 |
| Date range param | `complexType: "RANGE"` |
| Pie chart value | `encodings.angle` |
| Table rows | `disaggregated: true` |
| Counter spec | `version: 2` |
| Chart spec | `version: 3` |
| Table spec | `version: 1` |
| Filter spec | `version: 2` |

---

**Remember**: The grid system is **6 columns**, and every parameter used in SQL must be defined with `defaultSelection`!
